"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compiler = require("../compiler");

var _constants = require("../constants");

var _obfuscator = _interopRequireDefault(require("../obfuscator"));

var _order = require("../order");

var _probability = require("../probability");

var _template = _interopRequireDefault(require("../templates/template"));

var _traverse = _interopRequireWildcard(require("../traverse"));

var _gen = require("../util/gen");

var _identifiers = require("../util/identifiers");

var _insert = require("../util/insert");

var _random = require("../util/random");

var _transform = _interopRequireDefault(require("./transform"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Converts function to `new Function("..code..")` syntax as an alternative to `eval`. Eval is disabled in many environments.
 *
 * `new Function("..code..")` runs in an isolated context, meaning all local variables are undefined and throw errors.
 *
 * Rigorous checks are in place to only include pure functions.
 *
 * `flatten` can attempt to make function reference-less. Recommended to have flatten enabled with RGF.
 *
 * | Mode | Description |
 * | --- | --- |
 * | `"all"` | Applies to all scopes |
 * | `true` | Applies to the top level only |
 * | `false` | Feature disabled |
 */
class RGF extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.RGF);
  }

  match(object, parents) {
    return (0, _insert.isVarContext)(object) && object.type !== "ArrowFunctionExpression";
  }

  transform(contextObject, contextParents) {
    return () => {
      var isGlobal = contextObject.type == "Program";
      var value = (0, _probability.ComputeProbabilityMap)(this.options.rgf, x => x, isGlobal);

      if (value !== "all" && !isGlobal) {
        return;
      }

      var collect = [];
      var queue = [];
      var names = new Map();
      var referenceSignatures = {};
      var definingNodes = new Map();
      (0, _traverse.walk)(contextObject, contextParents, (object, parents) => {
        if (object !== contextObject && (0, _insert.isFunction)(object) && !object.$requiresEval && !object.async && !object.generator && (0, _insert.getVarContext)(parents[0], parents.slice(1)) === contextObject) {
          var _this$options$lock;

          // Discard getter/setter methods
          if (parents[0].type === "Property" && parents[0].value === object) {
            if (parents[0].method || parents[0].kind === "get" || parents[0].kind === "set") {
              return;
            }
          } // Discard class methods


          if (parents[0].type === "MethodDefinition" && parents[0].value === object) {
            return;
          } // Avoid applying to the countermeasures function


          if (typeof ((_this$options$lock = this.options.lock) === null || _this$options$lock === void 0 ? void 0 : _this$options$lock.countermeasures) === "string") {
            // function countermeasures(){...}
            if (object.type === "FunctionDeclaration" && object.id.type === "Identifier" && object.id.name === this.options.lock.countermeasures) {
              return;
            } // var countermeasures = function(){...}


            if (parents[0].type === "VariableDeclarator" && parents[0].init === object && parents[0].id.type === "Identifier" && parents[0].id.name === this.options.lock.countermeasures) {
              return;
            }
          }

          var defined = new Set(),
              referenced = new Set();
          var isBound = false;
          /**
           * The fnTraverses serves two important purposes
           *
           * - Identify all the variables referenced and defined here
           * - Identify is the 'this' keyword is used anywhere
           *
           * @param o
           * @param p
           * @returns
           */

          const fnTraverser = (o, p) => {
            if (o.type == "Identifier" && !_constants.reservedIdentifiers.has(o.name) && !this.options.globalVariables.has(o.name)) {
              var info = (0, _identifiers.getIdentifierInfo)(o, p);

              if (!info.spec.isReferenced) {
                return;
              }

              if (info.spec.isDefined && (0, _insert.getDefiningContext)(o, p) === object) {
                defined.add(o.name);
              } else {
                referenced.add(o.name);
              }
            }

            if (o.type == "ThisExpression" || o.type == "Super") {
              isBound = true;
            }
          };

          (0, _traverse.walk)(object.params, [object, ...parents], fnTraverser);
          (0, _traverse.walk)(object.body, [object, ...parents], fnTraverser);

          if (!isBound) {
            var _object$id;

            defined.forEach(identifier => {
              referenced.delete(identifier);
            });
            object.params.forEach(param => {
              referenced.delete(param.name);
            });
            collect.push({
              location: [object, parents],
              references: referenced,
              name: (_object$id = object.id) === null || _object$id === void 0 ? void 0 : _object$id.name
            });
          }
        }
      });

      if (!collect.length) {
        return;
      }

      var miss = 0;
      var start = collect.length * 2;

      while (true) {
        var hit = false;
        collect.forEach(_ref => {
          let {
            name,
            references: references1,
            location: location1
          } = _ref;

          if (!references1.size && name) {
            collect.forEach(o => {
              if (o.location[0] !== location1[0] && o.references.size && o.references.delete(name)) {
                // console.log(collect);
                hit = true;
              }
            });
          }
        });

        if (hit) {
          miss = 0;
        } else {
          miss++;
        }

        if (miss > start) {
          break;
        }
      }

      queue = [];
      collect.forEach(o => {
        if (!o.references.size) {
          var [object, parents] = o.location;
          queue.push([object, parents]);

          if (object.type == "FunctionDeclaration" && typeof object.id.name === "string") {
            var index = names.size;
            names.set(object.id.name, index);
            referenceSignatures[index] = (0, _random.getRandomString)(10);
            definingNodes.set(object.id.name, object.id);
          }
        }
      });

      if (!queue.length) {
        return;
      } // An array containing all the function declarations


      var referenceArray = "_" + (0, _random.getRandomString)(10);
      (0, _traverse.walk)(contextObject, contextParents, (o, p) => {
        if (o.type == "Identifier" && !_constants.reservedIdentifiers.has(o.name)) {
          var index = names.get(o.name);

          if (typeof index === "number") {
            var info = (0, _identifiers.getIdentifierInfo)(o, p);

            if (info.spec.isReferenced && !info.spec.isDefined) {
              var location = (0, _identifiers.getDefiningIdentifier)(o, p);

              if (location) {
                var pointingTo = location[0];
                var shouldBe = definingNodes.get(o.name); // console.log(pointingTo, shouldBe);

                if (pointingTo == shouldBe) {
                  this.log(o.name, "->", "".concat(referenceArray, "[").concat(index, "]"));
                  var memberExpression = (0, _gen.MemberExpression)((0, _gen.Identifier)(referenceArray), (0, _gen.Literal)(index), true); // Allow re-assignment to the RGF function

                  if (p[0] && p[0].type === "AssignmentExpression" && p[0].left === o) {
                    // fn = ...
                    this.replace(o, memberExpression);
                  } else {
                    // fn()
                    // fn
                    // In most cases the identifier is being used like this (call expression, or referenced to be called later)
                    // Replace it with a simple wrapper function that will pass on the reference array
                    var conditionalExpression = (0, _gen.ConditionalExpression)((0, _template.default)("typeof ".concat(referenceArray, "[").concat(index, "] === \"function\" && ").concat(referenceArray, "[").concat(index, "][\"").concat(referenceSignatures[index] || "_", "\"]")).single().expression, (0, _gen.FunctionExpression)([], [(0, _gen.ReturnStatement)( // clone() is required!
                    (0, _gen.CallExpression)((0, _insert.clone)(memberExpression), [(0, _gen.Identifier)(referenceArray), (0, _gen.SpreadElement)((0, _gen.Identifier)("arguments"))]))]), (0, _insert.clone)(memberExpression));
                    this.replace(o, conditionalExpression);
                  }
                }
              }
            }
          }
        }
      });
      var arrayExpression = (0, _gen.ArrayExpression)([]);
      var variableDeclaration = (0, _gen.VariableDeclaration)([(0, _gen.VariableDeclarator)((0, _gen.Identifier)(referenceArray), arrayExpression)]);
      (0, _insert.prepend)(contextObject, variableDeclaration);
      queue.forEach(_ref2 => {
        var _object$id2;

        let [object, parents] = _ref2;
        var name = object === null || object === void 0 ? void 0 : (_object$id2 = object.id) === null || _object$id2 === void 0 ? void 0 : _object$id2.name;
        var signature = referenceSignatures[names.get(name)];
        var embeddedName = name || this.getPlaceholder(); // Since `new Function` is completely isolated, create an entire new obfuscator and run remaining transformations.
        // RGF runs early and needs completed code before converting to a string.
        // (^ the variables haven't been renamed yet)

        var obfuscator = new _obfuscator.default({ ...this.options,
          rgf: false,
          globalVariables: new Set([...this.options.globalVariables, referenceArray]),
          lock: {
            integrity: false
          },
          eval: false,
          stringEncoding: false
        });
        var transforms = obfuscator.array.filter(x => x.priority > this.priority);
        var embeddedFunction = { ...object,
          type: "FunctionDeclaration",
          id: (0, _gen.Identifier)(embeddedName)
        };
        var tree = {
          type: "Program",
          body: [embeddedFunction, (0, _gen.ReturnStatement)((0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.Identifier)(embeddedName), (0, _gen.Literal)("call"), true), [(0, _gen.Identifier)("undefined"), (0, _gen.SpreadElement)((0, _template.default)("Array.prototype.slice.call(arguments, 1)").single().expression)]))]
        };
        tree.__hiddenDeclarations = (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(referenceArray));
        tree.__hiddenDeclarations.hidden = true;
        tree.__hiddenDeclarations.declarations[0].id.hidden = true;
        transforms.forEach(transform => {
          transform.apply(tree);
        }); // Find eval callbacks

        (0, _traverse.default)(tree, (o, p) => {
          if (o.$eval) {
            return () => {
              o.$eval(o, p);
            };
          }
        });
        var toString = (0, _compiler.compileJsSync)(tree, this.options);
        var newFunction = (0, _gen.NewExpression)((0, _gen.Identifier)("Function"), [(0, _gen.Literal)(referenceArray), (0, _gen.Literal)(toString)]);

        function applySignature(fn) {
          if (!signature) {
            return fn;
          } // This code marks the function object with a unique property


          return (0, _gen.CallExpression)((0, _gen.FunctionExpression)([], [(0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)("fn", fn)), (0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("=", (0, _gen.MemberExpression)((0, _gen.Identifier)("fn"), (0, _gen.Literal)(signature), true), (0, _gen.Literal)(true))), (0, _gen.ReturnStatement)((0, _gen.Identifier)("fn"))]), []);
        }

        if (object.type === "FunctionDeclaration") {
          arrayExpression.elements[names.get(name)] = applySignature(newFunction);

          if (Array.isArray(parents[0])) {
            parents[0].splice(parents[0].indexOf(object), 1);
          } else {
            this.error(new Error("Error deleting function declaration: " + parents.map(x => x.type).join(",")));
          }
        } else {
          // The wrapper function passes the reference array around
          var wrapperFunction = (0, _gen.FunctionExpression)([], [(0, _gen.ReturnStatement)((0, _gen.CallExpression)((0, _gen.MemberExpression)(newFunction, (0, _gen.Literal)("call"), true), [(0, _gen.Identifier)("undefined"), (0, _gen.Identifier)(referenceArray), (0, _gen.SpreadElement)((0, _gen.Identifier)("arguments"))]))]);
          this.replace(object, applySignature(wrapperFunction));
        }
      });
    };
  }

}

exports.default = RGF;