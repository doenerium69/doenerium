"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transform = _interopRequireDefault(require("../transform"));

var _gen = require("../../util/gen");

var _insert = require("../../util/insert");

var _compare = require("../../util/compare");

var _order = require("../../order");

var _stringConcealing = require("../string/stringConcealing");

var _probability = require("../../probability");

var _assert = require("assert");

var _random = require("../../util/random");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * [Duplicate Literals Removal](https://docs.jscrambler.com/code-integrity/documentation/transformations/duplicate-literals-removal) replaces duplicate literals with a variable name.
 *
 * - Potency Medium
 * - Resilience Medium
 * - Cost Medium
 *
 * ```js
 * // Input
 * var foo = "http://www.example.xyz";
 * bar("http://www.example.xyz");
 *
 * // Output
 * var a = "http://www.example.xyz";
 * var foo = a;
 * bar(a);
 * ```
 */
class DuplicateLiteralsRemoval extends _transform.default {
  /**
   * getter fn name -> accumulative shift
   */

  /**
   * lex context -> getter fn name
   */
  constructor(o) {
    super(o, _order.ObfuscateOrder.DuplicateLiteralsRemoval);

    _defineProperty(this, "arrayName", void 0);

    _defineProperty(this, "arrayExpression", void 0);

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "first", void 0);

    _defineProperty(this, "fnShifts", void 0);

    _defineProperty(this, "fnGetters", void 0);

    this.map = new Map();
    this.first = new Map();
    this.fnShifts = new Map();
    this.fnGetters = new Map();
  }

  apply(tree) {
    super.apply(tree);

    if (this.arrayName && this.arrayExpression.elements.length) {
      var getArrayFn = this.getPlaceholder();
      (0, _insert.append)(tree, (0, _gen.FunctionDeclaration)(getArrayFn, [], [(0, _gen.ReturnStatement)(this.arrayExpression)]));
      (0, _insert.prepend)(tree, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(this.arrayName, (0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.Identifier)(getArrayFn), (0, _gen.Identifier)("call"), false), [(0, _gen.ThisExpression)()]))));
    }
  }

  match(object, parents) {
    return (0, _compare.isPrimitive)(object) && !(0, _compare.isDirective)(object, parents) && !(0, _stringConcealing.isModuleSource)(object, parents) && !parents.find(x => x.$dispatcherSkip);
  }
  /**
   * Converts ordinary literal to go through a getter function.
   * @param object
   * @param parents
   * @param index
   */


  toCaller(object, parents, index) {
    // get all the getters defined here or higher
    var getterNames = [object, ...parents].map(x => this.fnGetters.get(x)).filter(x => x); // use random getter function

    var getterName = (0, _random.choice)(getterNames); // get this literals context

    var lexContext = (0, _insert.getLexContext)(object, parents);
    var hasGetterHere = this.fnGetters.has(lexContext); // create one if none are available (or by random chance if none are here locally)

    var shouldCreateNew = !getterName || !hasGetterHere && Math.random() > 0.9;

    if (shouldCreateNew) {
      (0, _assert.ok)(!this.fnGetters.has(lexContext));
      var lexContextIndex = parents.findIndex(x => x !== lexContext && (0, _insert.isLexContext)(x));
      var basedOn = lexContextIndex !== -1 ? (0, _random.choice)(parents.slice(lexContextIndex + 1).map(x => this.fnGetters.get(x)).filter(x => x)) : null;
      var body = [];
      var thisShift = (0, _random.getRandomInteger)(-250, 250); // the name of the getter

      getterName = this.getPlaceholder() + "_dLR_" + this.fnGetters.size;

      if (basedOn) {
        var shift = this.fnShifts.get(basedOn);
        (0, _assert.ok)(typeof shift === "number");
        body = [(0, _gen.ReturnStatement)((0, _gen.CallExpression)((0, _gen.Identifier)(basedOn), [(0, _gen.BinaryExpression)("+", (0, _gen.Identifier)("index"), (0, _gen.Literal)(thisShift))]))];
        this.fnShifts.set(getterName, shift + thisShift);
      } else {
        // from scratch
        body = [(0, _gen.ReturnStatement)((0, _gen.MemberExpression)((0, _gen.Identifier)(this.arrayName), (0, _gen.BinaryExpression)("+", (0, _gen.Identifier)("index"), (0, _gen.Literal)(thisShift)), true))];
        this.fnShifts.set(getterName, thisShift);
      }

      this.fnGetters.set(lexContext, getterName);
      (0, _insert.prepend)(lexContext, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(getterName, (0, _gen.CallExpression)((0, _gen.FunctionExpression)([], [(0, _gen.ReturnStatement)((0, _gen.FunctionExpression)([(0, _gen.Identifier)("index")], body))]), []))));
    }

    var theShift = this.fnShifts.get(getterName);
    this.replaceIdentifierOrLiteral(object, (0, _gen.CallExpression)((0, _gen.Identifier)(getterName), [(0, _gen.Literal)(index - theShift)]), parents);
  }

  transform(object, parents) {
    return () => {
      var value = object.value;

      if (object.regex) {
        return;
      }

      if (!(0, _probability.ComputeProbabilityMap)(this.options.duplicateLiteralsRemoval)) {
        return;
      } // HARD CODED LIMIT of 10,000 (after 1,000 elements)


      if (this.map.size > 1000 && !(0, _random.chance)(this.map.size / 100)) return;

      if (this.arrayName && parents[0].object && parents[0].object.name == this.arrayName) {
        return;
      }

      var value;

      if (object.type == "Literal") {
        value = typeof object.value + ":" + object.value;

        if (object.value === null) {
          value = "null:null";
        } else {
          // Skip empty strings
          if (typeof object.value === "string" && !object.value) {
            return;
          }
        }
      } else if (object.type == "Identifier") {
        value = "identifier:" + object.name;
      } else {
        throw new Error("Unsupported primitive type: " + object.type);
      }

      (0, _assert.ok)(value);

      if (!this.first.has(value) && !this.map.has(value)) {
        this.first.set(value, [object, parents]);
      } else {
        if (!this.arrayName) {
          this.arrayName = this.getPlaceholder();
          this.arrayExpression = (0, _gen.ArrayExpression)([]);
        }

        var firstLocation = this.first.get(value);

        if (firstLocation) {
          this.first.set(value, null);
          var index = this.map.size;
          (0, _assert.ok)(!this.map.has(value));
          this.map.set(value, index);
          var pushing = (0, _insert.clone)(object);
          this.arrayExpression.elements.push(pushing);
          (0, _assert.ok)(this.arrayExpression.elements[index] === pushing);
          this.toCaller(firstLocation[0], firstLocation[1], index);
        }

        var index = this.map.get(value);
        (0, _assert.ok)(typeof index === "number");
        this.toCaller(object, parents, index);
      }
    };
  }

}

exports.default = DuplicateLiteralsRemoval;