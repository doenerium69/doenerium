"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _order = require("../order");

var _probability = require("../probability");

var _template = _interopRequireDefault(require("../templates/template"));

var _traverse = require("../traverse");

var _gen = require("../util/gen");

var _insert = require("../util/insert");

var _random = require("../util/random");

var _transform = _interopRequireDefault(require("./transform"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const templates = [(0, _template.default)("\n  function curCSS( elem, name, computed ) {\n    var ret;\n  \n    computed = computed || getStyles( elem );\n  \n    if ( computed ) {\n      ret = computed.getPropertyValue( name ) || computed[ name ];\n  \n      if ( ret === \"\" && !isAttached( elem ) ) {\n        ret = redacted.style( elem, name );\n      }\n    }\n  \n    return ret !== undefined ?\n  \n      // Support: IE <=9 - 11+\n      // IE returns zIndex value as an integer.\n      ret + \"\" :\n      ret;\n  }"), (0, _template.default)("\n  function Example() {\n    var state = redacted.useState(false);\n    return x(\n      ErrorBoundary,\n      null,\n      x(\n        DisplayName,\n        null,\n      )\n    );\n  }"), (0, _template.default)("\n  const path = require('path');\nconst { version } = require('../../package');\nconst { version: dashboardPluginVersion } = require('@redacted/enterprise-plugin/package');\nconst { version: componentsVersion } = require('@redacted/components/package');\nconst { sdkVersion } = require('@redacted/enterprise-plugin');\nconst isStandaloneExecutable = require('../utils/isStandaloneExecutable');\nconst resolveLocalRedactedPath = require('./resolve-local-redacted-path');\n\nconst redactedPath = path.resolve(__dirname, '../redacted.js');"), (0, _template.default)("\nmodule.exports = async (resolveLocalRedactedPath = ()=>{throw new Error(\"No redacted path provided\")}) => {\n  const cliParams = new Set(process.argv.slice(2));\n  if (!cliParams.has('--version')) {\n    if (cliParams.size !== 1) return false;\n    if (!cliParams.has('-v')) return false;\n  }\n\n  const installationModePostfix = await (async (isStandaloneExecutable, redactedPath) => {\n    if (isStandaloneExecutable) return ' (standalone)';\n    if (redactedPath === (await resolveLocalRedactedPath())) return ' (local)';\n    return '';\n  })();\n\n  return true;\n};"), (0, _template.default)("\nfunction setCookie(cname, cvalue, exdays) {\n  var d = new Date();\n  d.setTime(d.getTime() + (exdays*24*60*60*1000));\n  var expires = \"expires=\"+ d.toUTCString();\n  document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\n}"), (0, _template.default)("function getCookie(cname) {\n  var name = cname + \"=\";\n  var decodedCookie = decodeURIComponent(document.cookie);\n  var ca = decodedCookie.split(';');\n  for(var i = 0; i <ca.length; i++) {\n    var c = ca[i];\n    while (c.charAt(0) == ' ') {\n      c = c.substring(1);\n    }\n    if (c.indexOf(name) == 0) {\n      return c.substring(name.length, c.length);\n    }\n  }\n  return \"\";\n}"), (0, _template.default)("function getLocalStorageValue(key, cb){\n    if ( typeof key !== \"string\" ) {\n      throw new Error(\"Invalid data key provided (not type string)\")\n    }\n    if ( !key ) {\n      throw new Error(\"Invalid data key provided (empty string)\")\n    }\n    var value = window.localStorage.getItem(key)\n    try {\n      value = JSON.parse(value)\n    } catch ( e ) {\n      cb(new Error(\"Serialization error for data '\" + key + \"': \" + e.message))\n    }\n\n    cb(null, value)\n  }"), (0, _template.default)("\n  \n    var __ = \"(c=ak(<~F$VU'9f)~><&85dBPL-module/from\";\n    var s = \"q:function(){var ad=ad=>b(ad-29);if(!T.r[(typeof ab==ad(123)?\";\n    var g = \"return U[c[c[d(-199)]-b(205)]]||V[ae(b(166))];case T.o[c[c[c[d(-199)]+d(-174)]-(c[b(119)]-(c[d(-199)]-163))]+ae(b(146))](0)==b(167)?d(-130):-d(-144)\";\n\n    __.match(s + g);\n  "), (0, _template.default)("\n  function vec_pack(vec) {\n    return vec[1] * 67108864 + (vec[0] < 0 ? 33554432 | vec[0] : vec[0]);\n  }\n  \n  function vec_unpack(number) {\n    switch (((number & 33554432) !== 0) * 1 + (number < 0) * 2) {\n      case 0:\n        return [number % 33554432, Math.trunc(number / 67108864)];\n      case 1:\n        return [\n          (number % 33554432) - 33554432,\n          Math.trunc(number / 67108864) + 1,\n        ];\n      case 2:\n        return [\n          (((number + 33554432) % 33554432) + 33554432) % 33554432,\n          Math.round(number / 67108864),\n        ];\n      case 3:\n        return [number % 33554432, Math.trunc(number / 67108864)];\n    }\n  }\n  \n  let a = vec_pack([2, 4]);\n  let b = vec_pack([1, 2]);\n  \n  let c = a + b; // Vector addition\n  let d = c - b; // Vector subtraction\n  let e = d * 2; // Scalar multiplication\n  let f = e / 2; // Scalar division\n  \n  console.log(vec_unpack(c)); // [3, 6]\n  console.log(vec_unpack(d)); // [2, 4]\n  console.log(vec_unpack(e)); // [4, 8]\n  console.log(vec_unpack(f)); // [2, 4]\n  "), (0, _template.default)("\n  function buildCharacterMap(str) {\n    const characterMap = {};\n  \n    for (let char of str.replace(/[^w]/g, \"\").toLowerCase())\n      characterMap[char] = characterMap[char] + 1 || 1;\n  \n    return characterMap;\n  }\n  \n  function isAnagrams(stringA, stringB) {\n    const stringAMap = buildCharMap(stringA);\n    const stringBMap = buildCharMap(stringB);\n  \n    for (let char in stringAMap) {\n      if (stringAMap[char] !== stringBMap[char]) {\n        return false;\n      }\n    }\n  \n    if (Object.keys(stringAMap).length !== Object.keys(stringBMap).length) {\n      return false;\n    }\n  \n    return true;\n  }\n  \n  /**\n   * @param {TreeNode} root\n   * @return {boolean}\n   */\n  function isBalanced(root) {\n    const height = getHeightBalanced(root);\n    return height !== Infinity;\n  }\n  \n  function getHeightBalanced(node) {\n    if (!node) {\n      return -1;\n    }\n  \n    const leftTreeHeight = getHeightBalanced(node.left);\n    const rightTreeHeight = getHeightBalanced(node.right);\n  \n    const heightDiff = Math.abs(leftTreeHeight - rightTreeHeight);\n  \n    if (\n      leftTreeHeight === Infinity ||\n      rightTreeHeight === Infinity ||\n      heightDiff > 1\n    ) {\n      return Infinity;\n    }\n  \n    const currentHeight = Math.max(leftTreeHeight, rightTreeHeight) + 1;\n    return currentHeight;\n  }\n  \n  window[\"__GLOBAL__HELPERS__\"] = {\n    buildCharacterMap,\n    isAnagrams,\n    isBalanced,\n    getHeightBalanced,\n  };\n  "), (0, _template.default)("\n  function ListNode(){}\n  var addTwoNumbers = function(l1, l2) {\n    var carry = 0;\n    var sum = 0;\n    var head = new ListNode(0);\n    var now = head;\n    var a = l1;\n    var b = l2;\n    while (a !== null || b !== null) {\n      sum = (a ? a.val : 0) + (b ? b.val : 0) + carry;\n      carry = Math.floor(sum / 10);\n      now.next = new ListNode(sum % 10);\n      now = now.next;\n      a = a ? a.next : null;\n      b = b ? b.next : null;\n    }\n    if (carry) now.next = new ListNode(carry);\n    return head.next;\n  };\n\n  console.log(addTwoNumbers)\n  "), (0, _template.default)("\n  var threeSum = function(nums) {\n    var len = nums.length;\n    var res = [];\n    var l = 0;\n    var r = 0;\n    nums.sort((a, b) => (a - b));\n    for (var i = 0; i < len; i++) {\n      if (i > 0 && nums[i] === nums[i - 1]) continue;\n      l = i + 1;\n      r = len - 1;\n      while (l < r) {\n        if (nums[i] + nums[l] + nums[r] < 0) {\n          l++;\n        } else if (nums[i] + nums[l] + nums[r] > 0) {\n          r--;\n        } else {\n          res.push([nums[i], nums[l], nums[r]]);\n          while (l < r && nums[l] === nums[l + 1]) l++;\n          while (l < r && nums[r] === nums[r - 1]) r--;\n          l++;\n          r--;\n        }\n      }\n    }\n    return res;\n  };\n  console.log(threeSum)\n  "), (0, _template.default)("\n  var combinationSum2 = function(candidates, target) {\n    var res = [];\n    var len = candidates.length;\n    candidates.sort((a, b) => (a - b));\n    dfs(res, [], 0, len, candidates, target);\n    return res;\n  };\n\n  var dfs = function (res, stack, index, len, candidates, target) {\n    var tmp = null;\n    if (target < 0) return;\n    if (target === 0) return res.push(stack);\n    for (var i = index; i < len; i++) {\n      if (candidates[i] > target) break;\n      if (i > index && candidates[i] === candidates[i - 1]) continue;\n      tmp = Array.from(stack);\n      tmp.push(candidates[i]);\n      dfs(res, tmp, i + 1, len, candidates, target - candidates[i]);\n    }\n  };\n\n  console.log(combinationSum2);\n  "), (0, _template.default)("\n  var isScramble = function(s1, s2) {\n    return helper({}, s1, s2);\n  };\n  \n  var helper = function (dp, s1, s2) {\n    var map = {};\n  \n    if (dp[s1 + s2] !== undefined) return dp[s1 + s2];\n    if (s1 === s2) return true;\n  \n    for (var j = 0; j < s1.length; j++) {\n      if (map[s1[j]] === undefined) map[s1[j]] = 0;\n      if (map[s2[j]] === undefined) map[s2[j]] = 0;\n      map[s1[j]]++;\n      map[s2[j]]--;\n    }\n  \n    for (var key in map) {\n      if (map[key] !== 0) {\n        dp[s1 + s2] = false;\n        return false;\n      }\n    }\n  \n    for (var i = 1; i < s1.length; i++) {\n      if ((helper(dp, s1.substr(0, i), s2.substr(0, i))\n           && helper(dp, s1.substr(i), s2.substr(i))) ||\n          (helper(dp, s1.substr(0, i), s2.substr(s2.length - i))\n           && helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))) {\n        dp[s1 + s2] = true;\n        return true;\n      }\n    }\n  \n    dp[s1 + s2] = false;\n    return false;\n  };\n\n  console.log(isScramble);\n  "), (0, _template.default)("\n  var candy = function(ratings) {\n    var len = ratings.length;\n    var res = [];\n    var sum = 0;\n    for (var i = 0; i < len; i++) {\n      res.push((i !== 0 && ratings[i] > ratings[i - 1]) ? (res[i - 1] + 1) : 1);\n    }\n    for (var j = len - 1; j >= 0; j--) {\n      if (j !== len - 1 && ratings[j] > ratings[j + 1]) res[j] = Math.max(res[j], res[j + 1] + 1);\n      sum += res[j];\n    }\n    return sum;\n  };\n  \n  console.log(candy)\n  "), (0, _template.default)("\n  var maxPoints = function(points) {\n    var max = 0;\n    var map = {};\n    var localMax = 0;\n    var samePoint = 0;\n    var k = 0;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      map = {};\n      localMax = 0;\n      samePoint = 1;\n      for (var j = i + 1; j < len; j++) {\n        if (points[i].x === points[j].x && points[i].y === points[j].y) {\n          samePoint++;\n          continue;\n        }\n          if (points[i].y === points[j].y) k = Number.MAX_SAFE_INTEGER;\n          else k = (points[i].x - points[j].x) / (points[i].y - points[j].y);\n          if (!map[k]) map[k] = 0;\n          map[k]++;\n          localMax = Math.max(localMax, map[k]);\n      }\n      localMax += samePoint;\n      max = Math.max(max, localMax);\n    }\n    return max;\n  };\n  \n  console.log(maxPoints)\n  "), (0, _template.default)("\n  var maximumGap = function(nums) {\n    var len = nums.length;\n    if (len < 2) return 0;\n  \n    var max = Math.max(...nums);\n    var min = Math.min(...nums);\n    if (max === min) return 0;\n  \n    var minBuckets = Array(len - 1).fill(Number.MAX_SAFE_INTEGER);\n    var maxBuckets = Array(len - 1).fill(Number.MIN_SAFE_INTEGER);\n    var gap = Math.ceil((max - min) / (len - 1));\n    var index = 0;\n    for (var i = 0; i < len; i++) {\n      if (nums[i] === min || nums[i] === max) continue;\n      index = Math.floor((nums[i] - min) / gap);\n      minBuckets[index] = Math.min(minBuckets[index], nums[i]);\n      maxBuckets[index] = Math.max(maxBuckets[index], nums[i]);\n    }\n  \n    var maxGap = Number.MIN_SAFE_INTEGER;\n    var preVal = min;\n    for (var j = 0; j < len - 1; j++) {\n      if (minBuckets[j] === Number.MAX_SAFE_INTEGER && maxBuckets[j] === Number.MIN_SAFE_INTEGER) continue;\n      maxGap = Math.max(maxGap, minBuckets[j] - preVal);\n      preVal = maxBuckets[j];\n    }\n    maxGap = Math.max(maxGap, max - preVal);\n  \n    return maxGap;\n  };\n\n  console.log(maximumGap);\n  "), (0, _template.default)("\n  /**\n   * @param {number} capacity\n   */\n  var LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.length = 0;\n    this.map = {};\n    this.head = null;\n    this.tail = null;\n  };\n  \n  /** \n   * @param {number} key\n   * @return {number}\n   */\n  LRUCache.prototype.get = function(key) {\n    var node = this.map[key];\n    if (node) {\n      this.remove(node);\n      this.insert(node.key, node.val);\n      return node.val;\n    } else {\n      return -1;\n    }\n  };\n  \n  /** \n   * @param {number} key \n   * @param {number} value\n   * @return {void}\n   */\n  LRUCache.prototype.put = function(key, value) {\n    if (this.map[key]) {\n      this.remove(this.map[key]);\n      this.insert(key, value);\n    } else {\n      if (this.length === this.capacity) {\n        this.remove(this.head);\n        this.insert(key, value);\n      } else {\n        this.insert(key, value);\n        this.length++;\n      }\n    }\n  };\n  \n  /** \n   * Your LRUCache object will be instantiated and called as such:\n   * var obj = Object.create(LRUCache).createNew(capacity)\n   * var param_1 = obj.get(key)\n   * obj.put(key,value)\n   */\n  \n  LRUCache.prototype.remove = function (node) {\n    var prev = node.prev;\n    var next = node.next;\n    if (next) next.prev = prev;\n    if (prev) prev.next = next;\n    if (this.head === node) this.head = next;\n    if (this.tail === node) this.tail = prev;\n    delete this.map[node.key];\n  };\n  \n  LRUCache.prototype.insert = function (key, val) {\n    var node = new List(key, val);\n    if (!this.tail) {\n      this.tail = node;\n      this.head = node;\n    } else {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    }\n    this.map[key] = node;\n  };\n\n  console.log(LRUCache);\n  "), (0, _template.default)("\n  var isInterleave = function(s1, s2, s3) {\n    var dp = {};\n    if (s3.length !== s1.length + s2.length) return false;\n    return helper(s1, s2, s3, 0, 0, 0, dp);\n  };\n  \n  var helper = function (s1, s2, s3, i, j, k, dp) {\n    var res = false;\n  \n    if (k >= s3.length) return true;\n    if (dp['' + i + j + k] !== undefined) return dp['' + i + j + k];\n  \n    if (s3[k] === s1[i] && s3[k] === s2[j]) {\n      res = helper(s1, s2, s3, i + 1, j, k + 1, dp) || helper(s1, s2, s3, i, j + 1, k + 1, dp);\n    } else if (s3[k] === s1[i]) {\n      res = helper(s1, s2, s3, i + 1, j, k + 1, dp);\n    } else if (s3[k] === s2[j]) {\n      res = helper(s1, s2, s3, i, j + 1, k + 1, dp);\n    }\n  \n    dp['' + i + j + k] = res;\n  \n    return res;\n  };\n\n  console.log(isInterleave);\n  "), (0, _template.default)("\n  var solveNQueens = function(n) {\n    var res = [];\n    if (n === 1 || n >= 4) dfs(res, [], n, 0);\n    return res;\n  };\n  \n  var dfs = function (res, points, n, index) {\n    for (var i = index; i < n; i++) {\n      if (points.length !== i) return;\n      for (var j = 0; j < n; j++) {\n        if (isValid(points, [i, j])) {\n          points.push([i, j]);\n          dfs(res, points, n, i + 1);\n          if (points.length === n) res.push(buildRes(points));\n          points.pop();\n        }\n      }\n    }\n  };\n  \n  var buildRes = function (points) {\n    var res = [];\n    var n = points.length;\n    for (var i = 0; i < n; i++) {\n      res[i] = '';\n      for (var j = 0; j < n; j++) {\n        res[i] += (points[i][1] === j ? 'Q' : '.');\n      }\n    }\n    return res;\n  };\n  \n  var isValid = function (oldPoints, newPoint) {\n    var len = oldPoints.length;\n    for (var i = 0; i < len; i++) {\n      if (oldPoints[i][0] === newPoint[0] || oldPoints[i][1] === newPoint[1]) return false;\n      if (Math.abs((oldPoints[i][0] - newPoint[0]) / (oldPoints[i][1] - newPoint[1])) === 1) return false;\n    }\n    return true;\n  };\n\n  console.log(solveNQueens);\n  ")];
/**
 * Adds dead code to blocks.
 *
 * - Adds fake predicates.
 * - Adds fake code from various samples.
 */

class DeadCode extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.DeadCode);

    _defineProperty(this, "made", void 0);

    this.made = 0;
  }

  match(object, parents) {
    return (0, _insert.isFunction)(object) && (0, _traverse.isBlock)(object.body) && !parents.find(x => x.$dispatcherSkip);
  }

  transform(object, parents) {
    if (!(0, _probability.ComputeProbabilityMap)(this.options.deadCode)) {
      return;
    } // Hard-coded limit of 100 Dead Code insertions


    this.made++;

    if (this.made > 100) {
      return;
    }

    return () => {
      var body = (0, _insert.getBlockBody)(object); // Do not place code before Import statements or 'use strict' directives

      var safeOffset = 0;

      for (var node of body) {
        if (node.type === "ImportDeclaration" || node.directive) safeOffset++;else break;
      }

      var index = (0, _random.getRandomInteger)(safeOffset, body.length);
      var name = this.getPlaceholder();
      var variableDeclaration = (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(name, (0, _gen.Literal)(false)));
      var template;

      do {
        template = (0, _random.choice)(templates);
      } while (this.options.es5 && template.source.includes("async"));

      var ifStatement = (0, _gen.IfStatement)((0, _gen.Identifier)(name), template.compile(), null);
      body.splice(index, 0, ifStatement);
      (0, _insert.prepend)(object, variableDeclaration);
    };
  }

}

exports.default = DeadCode;